---
title: "Автоматизация выпуска проектов: от хаоса к стандартизированным практикам"
date: 2025-02-19T21:49:58+04:00
slug: "release-automation-best-practices"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250219215307280.webp"
tags:
  - "DevOps"
  - "непрерывная интеграция"
  - "автоматический"
  - "передовая практика"
---

Недавно, оптимизируя процесс выпуска проекта, мы обнаружили, что, хотя все мы знаем, что "спецификация важна", на практике мы часто попадаем в странный круг "игнорирования спецификации ради быстрого выпуска". В этой статье мы расскажем о том, как автоматизировать инструменты и стандартизировать процессы, чтобы сделать выпуск проекта более контролируемым и эффективным.

<! -еще-->

## От ручного к автоматизированному: зачем меняться?

В традиционном ручном процессе выпуска релизов нам обычно нужно:
1. вручную изменить номер версии
2. обновить журнал изменений
3. создать релиз
4. опубликовать на платформе управления пакетами

У этого процесса есть несколько очевидных проблем:
- Легко забыть обновить номер версии.
- Формат журнала изменений непоследователен
- качество примечаний к выпуску различно
- этапы выпуска могут быть пропущены

Что еще более важно, ручные процессы делают процесс выпуска непредсказуемым и трудно повторяемым. Нам требовалось более автоматизированное и стандартизированное решение.

## Варианты инструментов автоматизации

Среди множества доступных средств автоматизации семейство инструментов semantic-release (в частности, python-semantic-release) представляет собой комплексное решение. Оно способно:

1. автоматически определять номер версии
2. автоматически генерировать журналы изменений
3. автоматически создавать релизы
4. автоматически выпускать релизы на PyPI

Основная идея инструмента заключается в том, чтобы управлять всем процессом выпуска через нормализованные сообщения коммитов.

## Нормализация сообщений фиксации

Чтобы в полной мере использовать преимущества инструментов автоматизации, сначала необходимо нормализовать сообщение о фиксации. Стандартный формат выглядит следующим образом:

```bash
<type>(<scope>): <description>

[可选的详细说明]

[可选的脚注]
```.

где type - основной компонент:
- feat: новая функция
- fix: исправления ошибок
- docs: обновление документации
- style: переформатирование кода
- refactor: рефакторинг кода
- test: связанное с тестированием
- chore: изменения в процессе сборки или вспомогательных инструментах

Пример:

```bash
feat(database): 添加连接池自动清理功能

添加了空闲连接的自动清理机制，可以通过配置设置清理时间间隔。
支持手动触发清理。

Breaking Changes:
- 移除了旧的手动连接关闭接口
```.

## Лучшие практики ветвления

Чтобы обеспечить качество и прослеживаемость коммитов, рекомендуется использовать модель разработки, основанную на ветвях:

```mermaid
flowchart TD
    A[main分支] -->|创建功能分支| B(feature/xxx)
    A -->|创建修复分支| C(fix/xxx)
    A -->|创建文档分支| D(docs/xxx)
    
    B -->|提交| E[Pull Request]
    C -->|提交| E
    D -->|提交| E
    
    E -->|review & squash| A
    
    A -->|触发| F[自动发布]
```.

### Соглашение об именовании ветвей
- feature/xxx: разработка новой функции
- исправление/xxx
- docs/xxx: обновление документации
- chore/xxx: обновление сценариев сборки

```mermaid
flowchart TD
    A[main分支] -->|创建功能分支| B(feature/xxx)
    A -->|创建修复分支| C(fix/xxx)
    A -->|创建文档分支| D(docs/xxx)
    
    B -->|本地提交| B1[feat: 添加新功能]
    B -->|本地提交| B2[test: 添加测试]
    
    C -->|本地提交| C1[fix: 修复错误]
    C -->|本地提交| C2[test: 验证修复]
    
    D -->|本地提交| D1[docs: 更新文档]
    
    B1 --> PR1[创建Pull Request]
    B2 --> PR1
    C1 --> PR2[创建Pull Request]
    C2 --> PR2
    D1 --> PR3[创建Pull Request]
    
    PR1 -->|review & squash| M[main分支]
    PR2 -->|review & squash| M
    PR3 -->|review & squash| M
    
    M -->|触发| AUTO[自动版本发布]
    
    classDef branch fill:#e1f5fe,stroke:#333,stroke-width:2px;
    classDef commit fill:#f9f9f9,stroke:#333,stroke-width:2px;
    classDef pr fill:#e8f5e9,stroke:#333,stroke-width:2px;
    classDef auto fill:#fce4ec,stroke:#333,stroke-width:2px;
    
    class A,B,C,D branch;
    class B1,B2,C1,C2,D1 commit;
    class PR1,PR2,PR3 pr;
    class M branch;
    class AUTO auto;
```.

### Pull Request Best Practices

1. используйте шаблоны, чтобы обеспечить предоставление необходимой информации
2. Проводите самопроверку кода
3. Используйте сквош при слиянии, чтобы сохранить историю мастер-ветки чистой
4. Убедитесь, что коммиты соответствуют спецификациям

## Автоматизируйте процесс выпуска

Полный автоматизированный процесс выпуска выглядит следующим образом:

```mermaid
flowchart TD
    subgraph 开发流程
        A[开发新功能] --> B[按规范提交代码]
        B --> C[创建Pull Request]
        C --> D[代码审查]
        D --> E[合并到main]
    end
    
    subgraph 自动化流程
        E --> F[分析提交历史]
        F --> G[计算版本号]
        G --> H[更新文件]
        H --> I[创建Release]
        I --> J[发布包]
    end
```

### Конфигурация инструмента

В случае с python-semantic-release вам нужно добавить конфигурацию в pyproject.toml:

```toml
[tool.semantic_release]
version_variable = [
    "pyproject.toml:version",
]
branch = "main"
upload_to_pypi = true
upload_to_release = true
build_command = "python -m build"
```.

### Конфигурация действий GitHub

```yaml
name: Release
on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Python Semantic Release
        uses: python-semantic-release/python-semantic-release@v8.7.2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
``` ## Конфигурация действий GitHub

### Рекомендации по лучшей практике

1. управление номерами версий
   - Строго следуйте спецификациям семантического версионирования
   - Позвольте инструменту автоматически обрабатывать обновления номеров версий
   - Не изменяйте номера версий вручную

2. Сообщения коммитов
   - Используйте инструменты (например, commitizen) для помощи в создании канонических коммитов
   - Проверяйте коммиты на предмет спецификации на стадии PR
   - Убедитесь, что финальное сообщение коммита является ясным и содержательным при слиянии

3. Стратегия работы с ветками
   - Защищайте мастер-ветку, которая должна быть объединена через PR
   - Используйте хорошо названную функциональную ветку
   - Своевременно удаляйте слитые ветки

4. Процесс выпуска
   - Настройте автоматизированные тесты для обеспечения качества кода
   - Используйте переменные окружения для управления конфиденциальной информацией
   - Ведение полной документации для каждого релиза

## Дополнительные предложения

1. предварительные выпуски
   - Использовать теги beta/alpha для предварительных выпусков
   - Полноценное тестирование в предрелизной среде

2. Управление несколькими пакетами
   - Рассмотрите возможность использования инструментов monorepo (например, changesets)
   - Рассмотрите возможность использования инструментов monorepo (например, changesets) для управления несколькими релизами пакетов

3. Уведомление о выпуске
   - Интеграция уведомлений со Slack/Pin и т. д.
   - Автоматическое генерирование уведомлений о выпуске

## Резюме

Автоматизация релизов - это не просто использование инструментов, это изменение культуры разработки. Она требует от нас:
- уделять больше внимания качеству наших коммитов
- уделять больше внимания стандартизации процесса разработки
- уделять больше внимания влиянию изменений кода

Стандартизируя и автоматизируя, мы можем:
- Повысить эффективность выпуска
- Сократить количество человеческих ошибок
- Повысить качество проекта
- Облегчить командную работу

Самое главное, что эти практики делают сопровождение проектов более устойчивым и профессиональным.

---

## Связанные ресурсы

- [Обычные коммиты](https://www.conventionalcommits.org/)
- [Семантическое версионирование](https://semver.org/)
- [python-semantic-release](https://python-semantic-release.readthedocs.io/)
- [GitHub Actions](https://docs.github.com/cn/actions)
- [About pull request merges](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges)
