---
title: "Автоматизация выпусков с помощью Semantic Release: подводные камни и решения"
date: 2025-03-13T21:15:50+04:00
slug: "automatic-versioning-with-semantic-release"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250313211837337.webp"
tags:
  - "DevOps"
  - "Git"
  - "автоматический"
  - "контроль версий"
---

В процессе разработки программного обеспечения версионирование кажется простым, но часто становится головной болью. Управлять версиями вручную не только утомительно, но и чревато ошибками. С помощью Semantic Release мы можем автоматизировать этот процесс, но есть некоторые подводные камни, которые можно легко упустить из виду. В этой статье мы расскажем о проблемах и решениях, с которыми столкнулась наша команда при использовании Semantic Release, чтобы помочь вам избежать этих подводных камней.

<!--more-->

## 问题背景：当自动化版本发布遇到了"拒绝发布"

Ли - начинающий инженер-программист, и его команда недавно начала использовать средства автоматизации для управления версиями проектов. Однажды он коммитит код, содержащий новую функцию, следуя обычному процессу, и, как ни странно, система непрерывной интеграции выдает следующее сообщение:

```
The type of the next release release is: no_release
```

Это означает, что, несмотря на то, что код был слит в мастер-ветку, автоматизированная система не считает изменения достаточными для создания нового релиза. Ли недоумевает, почему система не видит необходимости в новом релизе, ведь это явно важное обновление функций.

## 语义化版本（Semantic Versioning）是什么？

Прежде чем мы погрузимся в проблему, нам нужно понять, что такое семантизированная версия. Семантизированные версии обычно имеют формат `X.Y.Z`, где:

- **X**: номер основной версии - когда были внесены несовместимые изменения в API
- **Y**: номер минорной версии - когда была добавлена функциональность, совместимая с обратными изменениями
- **Z**: номер ревизии (Patch) - когда были сделаны исправления проблем, совместимых с обратным развитием.

Когда мы используем автоматизированный инструмент, такой как Semantic Release, он будет использовать информацию о фиксации, чтобы определить, какую часть номера версии следует обновить, или даже определить, нужен ли новый релиз.

## 问题分析：提交信息格式的重要性

При более внимательном изучении журналов мы обнаружили проблему: Semantic Release анализировал коммиты в соответствии со спецификацией Conventional Commits. Эта спецификация требует, чтобы коммиты следовали определенному формату:

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

Значение `type` является ключевым и определяет, как будет изменен номер версии:

- `feat`: новая функция, вызывающая увеличение номера минорной версии (Y)
- `fix`: исправление проблем, вызывающее увеличение номера ревизии (Z)
- `perf`: оптимизация производительности, обычно вызывает увеличение номера ревизии

Такие типы, как `docs`, `style`, `refactor`, `test`, `chore` и т. д., по умолчанию не вызывают изменения версии.

Вот где кроется проблема Ли: он использует `feature:` вместо стандартного `feat:` в качестве типа коммита, или он использует `refactor:` для своих коммитов, из-за чего Semantic Release не может распознать необходимость нового релиза.

## 尝试的解决方案

Мы попробовали несколько способов решить эту проблему:

### 1. 修改历史提交顺序与内容

Сначала мы пытались упорядочить и изменить историю коммитов с помощью интерактивного rebase в Git'е:

```bash
git rebase -i HEAD~4  # 显示最近4个提交
# 修改提交顺序和内容
git push --force  # 强制推送到远程仓库
```

Однако такой подход не решил проблему, поскольку даже после изменения порядка фиксаций проблема с форматированием сообщения о фиксации осталась.

### 2. 检查 Semantic Release 配置

Далее мы проверили конфигурацию Semantic Release в проекте:

```json
{
  "branches": ["main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    ["@semantic-release/exec", {
      "verifyConditionsCmd": "uv --version",
      "prepareCmd": "sed -i.bak 's/version = \".*\"/version = \"${nextRelease.version}\"/g' pyproject.toml && rm -f pyproject.toml.bak",
      "publishCmd": "uv build"
    }],
    ["@semantic-release/git", {
      "assets": [
        "pyproject.toml",
        "CHANGELOG.md"
      ],
      "message": "chore(release): ${nextRelease.version}\n\n${nextRelease.notes}"
    }],
    ["@semantic-release/github", {
      "assets": [
        {"path": "dist/*.whl", "label": "Python Wheel ${nextRelease.version}"},
        {"path": "dist/*.tar.gz", "label": "Source Distribution ${nextRelease.version}"}
      ]
    }]
  ]
}
```

Это стандартная конфигурация, в которой нет пользовательских правил, запрещающих определенным типам коммитов вызывать релиз.

## 成功的解决方案

В итоге мы использовали простой, но эффективный метод:

1. Используйте `git cherry-pick` для извлечения нужных коммитов из резервной ветки.
2. Используйте `git rebase` и `git commit --amend`, чтобы изменить сообщение коммита с `feature:` или `refactor:` на стандартное `feat:`.
3. Принудительный push в удаленный репозиторий

```bash
git cherry-pick <commit-hash>
git rebase -i HEAD~
# 在编辑器中将 "feature:" 或 "refactor:" 改为 "feat:"
git push --force
```

На этот раз система CI/CD успешно распознала тип фиксации и автоматически добавила номер минорной версии проекта.

## 规范的提交信息类型参考

Чтобы избежать подобных проблем, здесь перечислены стандартные типы фиксации и соответствующие им влияния версий:

| тип представления | описание | влияние версии |
|---------|------|---------|
| `feat` | Новая функция | Добавить номер минорной версии (Y) |
| `fix` | Исправление ошибок | Добавить номер ревизии (Z) |
| `docs` | Изменения в документации | Обычно не вызывают изменения версии |
| `style` | Изменения стиля кода (не влияет на функциональность) | Обычно не вызывает ревизию | `refactor` | Изменения стиля кода (не влияет на функциональность) | Обычно не вызывает ревизию | `fix` | Исправление ошибок | Добавить номер ревизии (Z)
| `refactor` | Рефакторинг кода | Обычно не вызывает изменения версии |
| `perf` | Оптимизация производительности | Обычно вызывает увеличение номера ревизии | `test` | Рефакторинг кода
| `test` | Связанные с тестированием | Обычно не вызывают изменения ревизии | `build` | Рефакторинг кода
| `build` | Изменения в системе сборки | Обычно не вызывают увеличения номера ревизии |
| `ci` | Изменения конфигурации CI | Обычно не вызываются | `chore` | Связанные с тестами | Обычно не вызываются
| `chore` | Другие изменения | Обычно не вызываются | `build` | Изменения в системе сборки | Обычно не вызываются

Для деструктивных изменений можно использовать символ `! ` или добавить префикс `BREAKING CHANGE:` к сообщению о фиксации:

```
feat!: 添加了一个有破坏性的功能
```

возможно

```
feat: 添加了新功能

BREAKING CHANGE: 这个变更破坏了之前的API
```

Это приводит к увеличению номера основной версии (X).

## 自定义提交类型行为

Если вы хотите, чтобы некоторые типы коммитов, которые по умолчанию не вызывают изменения версии (например, `refactor`), также вызывали изменения версии, вы можете добавить в конфигурацию пользовательское правило:

```json
{
  "plugins": [
    ["@semantic-release/commit-analyzer", {
      "preset": "angular",
      "releaseRules": [
        {"type": "refactor", "release": "patch"}
      ]
    }],
    // 其他插件...
  ]
}
```

Таким образом, коммиты типа `refactor` будут также вызывать увеличение номера ревизии.

## 总结与经验

Во время этого пит-стопа мы усвоили несколько важных уроков:

1. **Строго следуйте спецификации фиксации, основанной на соглашениях**: используйте стандартные префиксы типов фиксации (`feat:`, `fix:` и т. д.), а не полные слова или варианты
2. **Понимайте влияние различных типов фиксации**: знайте, какие типы вызывают обновление версий, а какие нет
3. **Познакомьтесь с инструментами Git**: научитесь использовать такие инструменты, как `cherry-pick`, `rebase` и т. д., чтобы исправить проблемы с историей коммитов
4. **Сохраняйте конфигурацию простой**: сохраняйте конфигурацию по умолчанию, если у вас нет особых потребностей

Для команд рекомендуется добавить спецификацию Conventional Commit Specification в документацию команды и рассмотреть возможность использования инструмента проверки сообщений коммита (например, `commitlint`), чтобы убедиться, что все коммиты соответствуют спецификации.

Инструменты семантического версионирования могут значительно упростить управление версиями, но только в том случае, если мы должны понимать и следовать его правилам. Надеюсь, эта статья поможет вам избежать подобных подводных камней и успешно автоматизировать управление версиями.

## 相关资源

- [Официальная документация по спецификации Conventional Commit](https://www.conventionalcommits.org/zh-hans/v1.0.0/)
- [Репозиторий Semantic Release GitHub](https://github.com/semantic-release/semantic-release)
- [Git Interactive Changebase Tutorial](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2)