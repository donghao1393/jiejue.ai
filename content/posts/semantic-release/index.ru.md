---
title: "Автоматизация выпусков с помощью Semantic Release: подводные камни и решения"
date: 2025-03-13T21:15:50+04:00
slug: "automatic-versioning-with-semantic-release"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250313211837337.webp"
tags:
  - "DevOps"
  - "Git"
  - "автоматический"
  - "контроль версий"
---

В процессе разработки программного обеспечения версионирование кажется простым, но часто становится головной болью. Управлять версиями вручную не только утомительно, но и чревато ошибками. С помощью Semantic Release мы можем автоматизировать этот процесс, но есть некоторые подводные камни, которые можно легко упустить из виду. В этой статье мы расскажем о проблемах и решениях, с которыми столкнулась наша команда при использовании Semantic Release, чтобы помочь вам избежать этих подводных камней.

<! --подробнее-->

## История проблемы: когда автоматизированный выпуск встречается с "отказом от выпуска"

Ли - новый инженер-программист, команда которого недавно начала использовать средства автоматизации для управления релизами проекта. Однажды он коммитит новую функцию обычным способом, и, как ни странно, система непрерывной интеграции выдает следующее сообщение:

```
The type of the next release release is: no_release
```.

Это означает, что, несмотря на то, что код был слит в мастер-ветку, система автоматизации не считает изменения достаточными для запуска нового релиза. Ли недоумевает, почему система не видит необходимости в новом релизе, ведь это явно важное обновление функций.

## Что такое семантическое версионирование?

Прежде чем мы погрузимся в этот вопрос, нам нужно понять, что такое семантическое версионирование. Семантическое версионирование обычно имеет формат `X.Y.Z`, где:

- **X**: основной номер версии - когда были сделаны несовместимые изменения в API.
- **Y**: номер минорной версии - когда было сделано функциональное дополнение, совместимое с обратным развитием.
- **Z**: номер ревизии (патч) - когда исправляется проблема, совместимая с предыдущей версией.

Когда мы используем автоматизированные инструменты, такие как Semantic Release, они используют информацию о коммите, чтобы определить, какая часть номера версии должна быть обновлена, или даже если необходим новый релиз.

## Анализ проблемы: важность форматирования сообщений коммита

При более внимательном изучении журналов мы обнаружили, что Semantic Release анализирует коммиты в соответствии со спецификацией Conventional Commits. Эта спецификация требует, чтобы коммиты следовали определенному формату:

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```.

Ключевым является `type`, который определяет, как изменяется номер версии:

- `feat`: новая функция, которая вызывает незначительное увеличение номера версии (Y).
- `fix`: исправление проблем, вызывающее увеличение номера ревизии (Z).
- `perf`: оптимизация производительности, обычно вызывающая увеличение номера ревизии.

В то время как такие методы, как `docs`, `style`, `refactor`, `test`, `chore`, `feature:`, `feat:`, `refactor:` и `git cherry-pick`, используются для устранения проблем. INLINE_CODE_17__ и другие типы по умолчанию не вызывают изменения версии.

Вот где кроется проблема Ли: он использует `feature:` вместо стандартного `feat:` в качестве типа фиксации, или он использует `refactor:` для фиксации, что приводит к тому, что Семантический релиз не распознал, что требуется новый релиз.

## Попытка решения

Мы попробовали несколько подходов к решению этой проблемы:

### 1. Изменить порядок и содержание исторических коммитов

Сначала мы попробовали изменить порядок и содержание истории коммитов с помощью интерактивного rebase в Git'е:

```bash
git rebase -i HEAD~4  # 显示最近4个提交
# 修改提交顺序和内容
git push --force  # 强制推送到远程仓库
```.

Однако это не решило проблему, поскольку даже после переупорядочивания коммитов форматирование сообщений о коммитах оставалось проблематичным.

### 2. Проверка конфигурации семантического релиза

Далее мы проверили конфигурацию Semantic Release в проекте:

```json
{
  "branches": ["main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    ["@semantic-release/exec", {
      "verifyConditionsCmd": "uv --version",
      "prepareCmd": "sed -i.bak 's/version = \".*\"/version = \"${nextRelease.version}\"/g' pyproject.toml && rm -f pyproject.toml.bak",
      "publishCmd": "uv build"
    }],
    ["@semantic-release/git", {
      "assets": [
        "pyproject.toml",
        "CHANGELOG.md"
      ],
      "message": "chore(release): ${nextRelease.version}\n\n${nextRelease.notes}"
    }],
    ["@semantic-release/github", {
      "assets": [
        {"path": "dist/*.whl", "label": "Python Wheel ${nextRelease.version}"},
        {"path": "dist/*.tar.gz", "label": "Source Distribution ${nextRelease.version}"}
      ]
    }]
  ]
}
```

Это стандартная конфигурация без пользовательских правил, запрещающих определенным типам коммитов вызывать релиз.

## Успешные решения

В итоге мы остановились на простом, но эффективном подходе:

1. Извлеките нужные коммиты из резервной ветки с помощью `git cherry-pick`.
2. Измените коммиты с помощью `git rebase` и `git commit --amend`, чтобы изменить `feature:` или `refactor:` на стандартные `feature:` или `refactor:`. `feat:` в стандартный `feat:`. 3.
3. Принудительная отправка в удаленное хранилище

__PROTECTED__CODE_BLOCK_4__

На этот раз система CI/CD успешно распознала тип коммита и автоматически добавила номер минорной версии проекта.

## Указание типа сообщения фиксации

Чтобы избежать подобных проблем, вот список стандартных типов коммитов и соответствующих им влияний версий:

| commit type | description | version impact |
| ---------|------|---------|
| `feat` | Новая функция | Добавить номер минорной версии (Y)|
| `fix` | Исправление ошибок | Добавить номер ревизии (Z) |
| `docs` | Изменения в документации | Обычно не вызывают изменения версии |
| `style` | Изменение стиля кода (не влияет на функциональность) | Обычно не вызывает изменения релиза |
| `refactor` | Рефакторинг кода | Обычно не приводит к изменению версии |
| `perf` | Оптимизация производительности | Обычно приводит к увеличению номера ревизии |

| `build` | Изменения в системе сборки | Обычно не вызывают изменения ревизии | | `build` | Изменения в системе сборки | Обычно не вызывают изменения ревизии
| `ci` | Изменения конфигурации CI | Обычно не вызывают изменения версии | | `build` | Изменения системы сборки
| `chore` | Другие изменения | Обычно не вызывают изменения версии |

Для разрушительных изменений используйте символ `!` или добавьте префикс `BREAKING CHANGE:` к сообщению о фиксации:

```
feat!: 添加了一个有破坏性的功能
```

или

```
feat: 添加了新功能

BREAKING CHANGE: 这个变更破坏了之前的API
```.

Это вызывает увеличение номера основной версии (X).

## Поведение пользовательского типа фиксации

Если вы хотите, чтобы некоторые типы фиксации, которые по умолчанию не вызывают изменения версии (например, `refactor`), также вызывали изменения версии, вы можете добавить пользовательское правило в конфигурацию:

```json
{
  "plugins": [
    ["@semantic-release/commit-analyzer", {
      "preset": "angular",
      "releaseRules": [
        {"type": "refactor", "release": "patch"}
      ]
    }],
    // 其他插件...
  ]
}
```

Таким образом, коммиты типа `refactor` будут также вызывать увеличение номера ревизии.

## Резюме и извлеченные уроки

Из этого подводного камня мы извлекли несколько важных уроков:

1. **Строго следуйте спецификации фиксации на основе конвенций**: используйте стандартные префиксы типов фиксации (`feat:`, `fix:` и т. д.), а не полные слова или варианты
2. **Понимайте влияние различных типов коммитов**: знайте, какие типы коммитов вызывают обновление версий, а какие нет
3. **Познакомьтесь с инструментами Git**: научитесь использовать такие инструменты, как `cherry-pick`, `rebase` и т. д., чтобы исправить проблемы с историей коммитов
4. **Сохраняйте конфигурацию простой**: сохраняйте конфигурацию по умолчанию, если у вас нет особых потребностей

Для команд рекомендуется добавить спецификацию коммитов на основе конвенций в документацию команды и рассмотреть возможность использования инструмента проверки сообщений коммитов (например, `commitlint`), чтобы убедиться, что все коммиты соответствуют спецификации.

Инструменты семантического версионирования могут значительно упростить версионирование, но только если мы понимаем и следуем его правилам. Надеюсь, эта статья поможет вам избежать подобных ловушек и успешно автоматизировать версионирование.

## Связанные ресурсы

- [Официальная документация по спецификации Conventional Commit](https://www.conventionalcommits.org/zh-hans/v1.0.0/)
- [Репозиторий Semantic Release GitHub](https://github.com/semantic-release/semantic-release)
- [Git Interactive Changebase Tutorial](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2)
