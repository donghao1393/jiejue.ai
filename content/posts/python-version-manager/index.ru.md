---
title: "Разрешение множественных конфликтов зависимостей Python: pyenv и venv в действии"
date: Sun Apr 20 2025 20:09:43 GMT+0000 (Coordinated Universal Time)
slug: "python-version-management-with-pyenv"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250421001116715.webp"
tags:
  - "Python"
  - "Экологический менеджмент"
  - "инструмент разработки"
---

Версионность Python может стать основной болью для разработчиков в современной сложной и меняющейся среде разработки на Python. Как гармонично ужиться на одной машине со старыми проектами, требующими старых версий Python, с одной стороны, и современными фреймворками, требующими новейших функций, с другой? В этой статье мы расскажем о комбинированном использовании pyenv и venv для решения проблемы конфликта зависимостей версий Python.

<!--more-->

## 问题场景：当面对版本冲突

Недавно я пытался использовать uv в проекте, который использует uv ([uv modern Python package management tool](https://github.com/astral-sh/uv), [uv Quick Start Guide]({{< ref "/posts/python-uv/index_quick.md" >}} "Say goodbye to tedium: uv makes Python Environment Management Simpler and More Efficient") | [Deeper Understanding of the Technical Principles of uv]({{< ref "/posts/python-uv/index_deep.md" >}} "uv: Redefining the Future of Python Package Management and Environment Isolation") столкнулись с проблемой импорта локально собранной библиотеки PyTorch в свой проект. Хотя библиотека PyTorch прекрасно работает в исходной среде сборки, когда я пытаюсь импортировать ее в новый проект, процесс Python немедленно завершается с ошибкой Segmentation Fault.

Эта история не знакома многим разработчикам:

- Для проекта A требуется Python 3.6 и определенная версия зависимых библиотек.
- Для проекта B требуется Python 3.9 и различные версии тех же библиотек.
- Проект C использует новейший Python 3.12 и современные инструменты

Разработчики часто пробуют различные варианты: использование контейнеров Docker (но это усложняет работу), использование Conda (но установка громоздка) или постоянная деинсталляция и переустановка Python (неэффективно и чревато ошибками).

## 根因分析：为什么会出现版本冲突

В моем случае первопричиной проблемы была разница в версии Python:

```bash
# PyTorch构建环境
Python 3.9.6 (default, Mar 12 2025, 20:22:46)
[Clang 17.0.0 (clang-1700.0.13.3)] on darwin

# FramePack项目环境
Python 3.10.16 (main, Mar 17 2025, 21:30:07) [Clang 20.1.0 ] on darwin
```

Это позволяет ответить на два ключевых вопроса:

1. **ABI несовместимость**: модули расширения Python на C (например, ядро PyTorch) привязываются к определенной версии Python ABI (Application Binary Interface) во время компиляции. При загрузке в разных версиях Python эти модули могут работать некорректно или даже приводить к сбоям.

2. **Различия в инструментах управления окружающей средой**: традиционные venv и pip с одной стороны и современные uv - с другой, что приводит к разной логике разрешения зависимостей.

## 最佳解决方案：pyenv + venv

После исследований и практики я нашел элегантное решение: комбинация **pyenv + venv**. Это решение имеет несколько ключевых преимуществ:

- **Легкий**: занимает меньше места на диске, чем Conda
- **Гибкость**: позволяет точно контролировать версию Python
- **Совместимость**: бесшовная интеграция с существующими цепочками инструментов
- **Изоляция**: не влияет на системный Python

Вот конкретные шаги по реализации.

## 实施方案：手把手教程

### 第一步：安装pyenv

```bash
# macOS安装
brew install pyenv

# Linux安装
curl https://pyenv.run | bash
```

### 第二步：配置shell环境

Для пользователей оболочки Fish добавьте следующее в `~/.config/fish/config.fish`:

```fish
status --is-interactive; and pyenv init - | source
```

Для пользователей Bash/Zsh добавьте в соответствующий конфигурационный файл (`.bashrc`/`.zshrc`):

```bash
export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
```

### 第三步：安装所需的Python版本

```bash
# 列出可用版本
pyenv install --list

# 安装特定版本
pyenv install 3.9.18
pyenv install 3.10.16
```

### 第四步：为项目设置Python版本

```bash
# 设置全局默认版本（可选）
pyenv global 3.10.16

# 为特定项目设置版本
cd ~/path/to/project-a
pyenv local 3.9.18
```

### 第五步：创建虚拟环境

в каждом каталоге проекта:

```bash
# 创建虚拟环境
python -m venv env

# 激活环境（Fish shell）
source env/bin/activate.fish

# 或激活环境（Bash/Zsh）
source env/bin/activate
```

### 第六步：安装项目依赖

```bash
# 使用pip安装依赖
pip install -r requirements.txt

# 对于本地开发的包，使用editable模式安装
pip install -e /path/to/local/package
```

## 实际应用案例：解决PyTorch导入崩溃

Вернемся к исходной проблеме: локально собранный импорт PyTorch падает в окружении с разными версиями Python. Решение этой проблемы с помощью pyenv выглядит следующим образом:

```bash
# 1. 在PyTorch目录下创建正确版本的环境
cd ~/path/to/pytorch
pyenv local 3.9.18
python -m venv env
source env/bin/activate.fish
# ... 构建PyTorch ...

# 2. 在目标项目中使用相同的Python版本
cd ~/path/to/target-project
pyenv local 3.9.18
python -m venv env
source env/bin/activate.fish

# 3. 安装本地构建的PyTorch
pip install -e ~/path/to/pytorch

# 4. 验证导入
python -c "import torch; print(torch.__version__)"
```

Это решает проблему сегментных ошибок, вызванных различиями в версиях Python, поскольку мы убедились, что среда разработки и среда выполнения используют одну и ту же версию Python.

## 与现代工具协作：uv + pyenv

Для новых проектов менеджер пакетов uv предлагает более высокую производительность и лучшее разрешение зависимостей, чем pip. Мы можем использовать pyenv в сочетании с uv:

```bash
# 安装uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# 使用pyenv设置Python版本
cd ~/path/to/new-project
pyenv local 3.10.16

# 使用uv创建虚拟环境
uv venv

# 安装依赖
uv pip install -r requirements.txt
```

Эта комбинация позволяет нам:

- Используйте pyenv + venv для старых проектов, чтобы обеспечить совместимость версий.
- Используйте pyenv + uv для новых проектов, чтобы насладиться удобством современных инструментов.

## 最佳实践与注意事项

Вот несколько примеров использования схемы pyenv + venv:

1. **Запись среды компиляции**: Для самокомпилирующихся библиотек расширений Python (например, PyTorch) запишите подробную информацию о среде компиляции, включая версию Python, версию компилятора и т.д.

2. **Использование файлов `.python-version`**: Убедитесь, что члены команды используют согласованную версию Python, создав файл `.python-version` в корневом каталоге проекта.

3. **Блокировка версий зависимостей**: Используйте `pip freeze > requirements.txt` или более современный `pyproject.toml` для блокировки точных версий зависимостей.

4. **Использование обнаружения окружения**: Добавление кода обнаружения окружения в сценарии запуска проекта обеспечивает заблаговременное обнаружение проблем в несовместимых окружениях:

```python
import sys
if sys.version_info < (3, 9) or sys.version_info >= (3, 10):
    raise RuntimeError("This project requires Python 3.9.x")
```

5. **Для Apple Silicon Mac**: обратите особое внимание на проблемы совместимости между архитектурами x86 и ARM, которые могут потребовать использования специальных параметров компиляции.

## 结语

Версионность Python может показаться простой, но она сложна, особенно когда речь идет о больших проектах и расширениях на C. pyenv + venv предоставляет легкое, гибкое и мощное решение для решения проблем, связанных с конфликтом версий.

Разработчики, которые любят пробовать, могут продолжать использовать современные инструменты, такие как uv, в новых проектах, обеспечивая при этом согласованность базовой версии Python с помощью pyenv для беспрепятственного взаимодействия между старыми и новыми инструментами.

Как показывает мой опыт, такой подход не только решает проблемы с версионированием традиционных проектов, но и обеспечивает большую гибкость и эффективность рабочего процесса разработки.

Сталкивались ли вы с подобными проблемами конфликта версий Python? Как вы их решали? Не стесняйтесь делиться своим опытом и соображениями в разделе комментариев.