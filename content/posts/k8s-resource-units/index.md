---
title: "Kubernetes资源单位避坑指南：millicores、Mi与那些容易混淆的数值"
date: 2025-12-06T17:17:36+04:00
slug: 'k8s-resource-units-guide'
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20251206172649526.webp"
tags:
  - Kubernetes
  - DevOps
  - 运维
---

在Kubernetes中配置资源限制时，那些看似简单的数字背后藏着不少容易踩坑的细节。`cpu: 0.2`是百分比吗？`512Mi`和`512M`有什么区别？`kubectl top`显示的`10m`又是什么意思？这篇文章整理了DevOps工程师需要注意的资源单位概念。

<!--more-->

## CPU单位：不是频率，是时间片

看到`cpu: 0.2`这样的配置，很容易产生疑问：这是0.2%？还是0.2GHz？

答案都不是。Kubernetes的CPU单位表示的是**核心数**，本质上是时间片的分配比例。

`0.2`意味着该容器可以使用0.2个CPU核心的计算时间。换算成百分比，就是单个核心的20%时间片。在一个典型的100毫秒调度周期内，这个容器可以占用某个核心20毫秒的执行时间。

Kubernetes用"millicores"（毫核）作为CPU的细分单位，1个核心等于1000毫核。所以以下写法是等价的：

- `cpu: 0.2`
- `cpu: 200m`

当数值超过1000m时，意味着需要多个核心来满足。比如`cpu: 1500m`表示1.5个核心，调度器会确保有足够的核心资源可供该容器使用。

为什么不用Hz指定CPU资源？原因在于集群的硬件异构性——不同节点的CPU主频可能是2.4GHz或3.6GHz，现代CPU还有动态调频机制。用Hz指定会让调度变得不可预测。Kubernetes故意抽象掉底层硬件细节，让资源请求在不同硬件上有相对一致的语义。

## kubectl top 的数值解读

执行`kubectl top pod`时看到的`10m`或`35m`，同样是millicores，表示采样周期内的平均CPU时间占用。

计算方式：容器运行时通过cgroups统计实际CPU时间消耗，除以采样间隔，得出平均使用率。`10m`就是1%的单核使用率（10÷1000=1%），和Linux `top`命令显示的CPU百分比是同一个概念。

## 内存单位：二进制与十进制的5%差异

`Mi`和`M`看起来很像，实际上是两套不同的计量体系——带`i`的是二进制单位（1024进制），不带的是十进制单位（1000进制）。`512Mi`比`512M`大约多5%。

实际使用中建议**统一用带`i`的单位**，因为操作系统和大多数监控工具都按二进制计算内存。混用可能导致监控数据与配置预期不符。

关于这套单位体系的来历，以及它背后的国际标准化故事，可以参考[从Gi到联合国：一段被遗忘的国际化历史]({{< ref "/posts/international-standards-history/index.md" >}} "从Gi到联合国：一段被遗忘的国际化历史")。

## 百分比的相对性：HPA的计算基准

HPA（Horizontal Pod Autoscaler）中的`targetCPUUtilizationPercentage`是另一个容易误解的数值。它是**相对于Pod的request值**的百分比，不是相对于节点总CPU的百分比。

假设Pod配置了`requests.cpu: 200m`，HPA设置`targetCPUUtilizationPercentage: 80`，触发扩容的实际阈值是：

```
200m × 80% = 160m
```

如果误以为是节点总量的80%，在一个8核节点上就会期待6400m才触发扩容，实际行为会完全不符合预期。

## 绝对值与百分比：滚动更新的参数

Deployment滚动更新中的`maxSurge`和`maxUnavailable`支持两种写法：

- 绝对数字：`maxSurge: 2` 表示最多额外创建2个Pod
- 百分比：`maxSurge: 25%` 表示最多额外创建副本数25%的Pod

在10个副本的Deployment中，`maxSurge: 1`和`maxSurge: 10%`意义相同（10×10%=1，向上取整）。但`maxSurge: 1%`只有0.1个Pod，取整后可能是0或1，行为变得不确定。

建议在副本数较少时使用绝对数字，副本数较多时使用百分比，避免取整带来的意外。

## 总结

Kubernetes资源单位的设计逻辑是抽象化和标准化，但这种抽象带来了一些反直觉的地方：

1. **CPU的millicores是时间片比例**，不是频率，不是算力
2. **内存的Mi和M相差约5%**，建议统一使用二进制单位（带i）
3. **HPA百分比相对于request**，不是节点总量
4. **滚动更新参数注意绝对值与百分比的取整行为**

理解这些单位的真实含义，能避免很多配置上的隐性问题。
