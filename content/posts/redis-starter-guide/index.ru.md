---
title: "Redis primer: руководство по структуре данных, понятное даже новичку"
date: 2025-07-04T20:55:21+04:00
slug: "redis-starter-guide"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250704211411434.webp"
tags:
  - "Redis"
  - "всеобъемлющая база данных"
  - "(вычислительный) кэш"
  - "Начало работы"
---

Redis - одновременно знакомый и незнакомый термин для многих разработчиков. Возможно, мы слышали, что он быстрый и является базой данных in-memory, но когда действительно нужно связаться и использовать Redis, часто путаемся в его структуре данных и работе. В этой статье мы будем использовать визуальные диаграммы и практические операции, чтобы помочь белым людям без опыта работы с Redis быстро понять основные концепции Redis и как его использовать.

<!--more-->

## 第一印象：Redis是什么

Представьте, что вы работаете в библиотеке. Традиционные базы данных SQL похожи на большие библиотеки со строгой системой классификации, где каждая книга размещена на фиксированной полке в соответствии с десятичной классификацией Дьюи, и вам нужно сначала найти правильную область классификации, а затем искать каждую книгу по номеру.

А Redis - это как маленькая полка быстрого доступа на столе библиотекаря. Там хранятся все наиболее часто используемые справочники, и все, что вам нужно сделать, - это сказать библиотекарю название книги, и он мгновенно выдаст ее вам, что невероятно быстро. Но полка быстрого доступа имеет ограниченное пространство, она не может вместить все книги, и если администратор отлучается (перезагрузка сервера), книги может потребоваться переставить.

```mermaid
graph LR
    subgraph "传统数据库"
        SQL["SQL数据库<br/>磁盘存储<br/>表格结构<br/>持久化"]
    end
    
    subgraph "Redis缓存层"
        Redis["Redis<br/>内存存储<br/>键值结构<br/>超高速"]
    end
    
    APP["应用程序"] --> Redis
    Redis --> SQL
    
    Redis -.-> |缓存热点数据| APP
    SQL -.-> |主要数据存储| APP
```

## Redis的数据空间：16个独立房间

Redis обладает уникальной особенностью: внутри него находится 16 отдельных баз данных (с нумерацией 0-15). Это похоже на здание склада с 16 комнатами, в каждой из которых есть свои отдельные полки и предметы, не мешающие друг другу.

```mermaid
graph TD
    subgraph "Redis实例"
        DB0["数据库0<br/>默认连接<br/>存放系统级数据"]
        DB1["数据库1<br/>业务数据<br/>用户信息等"]
        DB2["数据库2<br/>缓存数据"]
        DB3["数据库3<br/>..."]
        DBO["数据库15<br/>..."]
    end
    
    USER["用户连接"] --> DB0
    USER -.-> |SELECT 1| DB1
    USER -.-> |SELECT 2| DB2
```

На практике, когда вы подключаетесь к Redis, по умолчанию используется база данных 0. Если вам нужно переключиться на другую базу данных, используйте команду `SELECT`:

```bash
# 默认在数据库0
redis-cli> KEYS *
1) "gq:search-index-docs-count"

# 切换到数据库1
redis-cli> SELECT 1
OK

# 现在在数据库1，可以看到完全不同的数据
redis-cli[1]> KEYS *
1) "client:all:quota_last_updated_minute"
2) "purchase:820f672f-98bf-9639-41b8-1150b535aef5:budget_v2"
...
```

Обратите внимание на изменения в подсказке командной строки: `[1]` в `redis-cli[1]>` означает, что вы сейчас находитесь в базе данных 1.

## Redis的数据类型：不只是简单的键值对

Если вы знакомы с Python или JSON, вы можете думать о парах ключ-значение как о строках, сопоставленных со строками. Однако Redis предоставляет пять специально оптимизированных типов данных, каждый из которых имеет определенное назначение:

### 1. 字符串（String）
最基础的类型，可以存储文本、数字、甚至二进制数据：

```bash
SET user:name "张三"
GET user:name
# 返回: "张三"

SET counter 100
INCR counter
# 返回: 101
```

### 2. 哈希（Hash）
这里的"哈希"不是加密概念，而是像Python字典一样的字段-值映射。特别适合存储对象信息：

```bash
HSET user:1000 name "张三" age 30 email "zhang@example.com"
HGETALL user:1000
# 返回:
# 1) "name"
# 2) "张三"
# 3) "age"
# 4) "30"
# 5) "email"
# 6) "zhang@example.com"
```

Именно такую структуру записи о покупке мы видели ранее:

```bash
HGETALL purchase:820f672f-98bf-9639-41b8-1150b535aef5:budget_v2
# 返回预算相关的4个字段和值
```

### 3. 列表（List）
有序的元素序列，支持从两端插入和删除：

```bash
LPUSH messages "最新消息"
LPUSH messages "较早消息"
LRANGE messages 0 -1
# 返回: ["最新消息", "较早消息"]
```

### 4. 集合（Set）
无序且不重复的元素集合：

```bash
SADD tags "redis" "数据库" "nosql"
SMEMBERS tags
# 返回: ["redis", "数据库", "nosql"]
```

### 5. 有序集合（Sorted Set）
每个元素都有一个分数，按分数排序：

```bash
ZADD leaderboard 100 "玩家A" 85 "玩家B" 120 "玩家C"
ZRANGE leaderboard 0 -1 WITHSCORES
# 返回按分数排序: ["玩家B", "85", "玩家A", "100", "玩家C", "120"]
```

```mermaid
graph TD
    subgraph "Redis数据类型"
        STRING["字符串<br/>简单键值对<br/>计数器"]
        HASH["哈希<br/>对象属性<br/>用户信息"]
        LIST["列表<br/>消息队列<br/>时间线"]
        SET["集合<br/>标签系统<br/>去重"]
        ZSET["有序集合<br/>排行榜<br/>优先级队列"]
    end
    
    STRING --> |"SET key value"| V1["value"]
    HASH --> |"HSET key field value"| V2["field1: value1<br/>field2: value2"]
    LIST --> |"LPUSH key value"| V3["[value3, value2, value1]"]
    SET --> |"SADD key value"| V4["{value1, value2, value3}"]
    ZSET --> |"ZADD key score value"| V5["value1: score1<br/>value2: score2"]
```

## Redis键名的命名艺术

В Redis нет реальной иерархии, все ключи плоские. Однако разработчики создали "псевдоиерархическое" соглашение об именовании, используя двоеточия (:):

```
purchase:820f672f-98bf-9639-41b8-1150b535aef5:budget_v2
^~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ^~~~~~~~~
类型      唯一标识符(UUID)                     属性/版本
```

Такая схема именования дает несколько преимуществ:

1. **Четкая организация**: с первого взгляда видно, для чего нужны данные
2. **Соответствующий шаблону запрос**: вы можете использовать символы подстановки для поиска связанных ключей
3. **Избежать конфликтов наименований**: ключи разных функциональных модулей не будут переименованы

```mermaid
graph LR
    subgraph "键名组织"
        K1["purchase:uuid1:budget_v2"] 
        K2["purchase:uuid1:order_info"]
        K3["purchase:uuid2:budget_v2"]
        K4["user:uuid1:profile"]
        K5["user:uuid1:settings"]
    end
    
    Q1["KEYS purchase:*"] --> K1
    Q1 --> K2
    Q1 --> K3
    
    Q2["KEYS *:budget_v2"] --> K1
    Q2 --> K3
    
    Q3["KEYS user:uuid1:*"] --> K4
    Q3 --> K5
```

Важно понимать, что для Redis вся строка - это имя ключа, без отношений "родитель-ребенок". Когда вы выполняете команду `KEYS purchase:*`, Redis возвращает все совпадающие полные имена ключей, а не `подкаталоги`, как в файловой системе.

## 实际操作：连接和查询Redis

### 连接到Redis

Если вы работаете в среде Kubernetes, вы можете создать Redis client Pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: redis-client
spec:
  containers:
  - name: redis-client
    image: redis
    command: [ "sh", "-c", "sleep 3h" ]
```

Затем перейдите в раздел Pod и подключитесь к Redis:

```bash
# 进入Pod
kubectl exec -it redis-cli -- bash

# 连接Redis（替换为你的实际连接信息）
redis-cli -h your-redis-host -p 6379 -a your-password

# 如果使用SSL（Azure Redis默认启用）
redis-cli -h your-redis-host -p 6380 --tls -a your-password
```

### 基础查询命令

После успешного подключения вы можете использовать эти неинтрузивные команды для изучения данных:

```bash
# 测试连接
PING
# 返回: PONG

# 查看当前数据库的所有键（小心使用，数据量大时会很慢）
KEYS *

# 更安全的方式：分批查看键
SCAN 0 MATCH purchase:* COUNT 10

# 查看数据库中键的总数
DBSIZE

# 检查特定键的类型
TYPE purchase:820f672f-98bf-9639-41b8-1150b535aef5:budget_v2
# 返回: hash

# 查看键的过期时间
TTL some-key
# 返回剩余秒数，-1表示永不过期，-2表示键不存在
```

### 根据数据类型查询内容

```bash
# 如果是字符串
GET key-name

# 如果是哈希
HGETALL key-name
HKEYS key-name    # 只看字段名
HVALS key-name    # 只看值

# 如果是列表
LRANGE key-name 0 -1   # 查看所有元素
LLEN key-name          # 查看列表长度

# 如果是集合
SMEMBERS key-name      # 查看所有成员
SCARD key-name         # 查看成员数量

# 如果是有序集合
ZRANGE key-name 0 -1 WITHSCORES  # 查看所有成员和分数
ZCARD key-name                   # 查看成员数量
```

## Redis的使用场景和价值

### 为什么需要Redis？

Основная сила Redis - это **скорость**. Будучи базой данных in-memory, она обеспечивает микросекундное время отклика, что особенно ценно в следующих сценариях:

1. **Слой кэша**: снижение нагрузки на базу данных
   - Храните горячие данные в Redis
   - Приложение сначала проверяет Redis, а затем базу данных, если она недоступна
   - Значительное повышение скорости отклика

2. **Функциональность в режиме реального времени**:
   - Количество пользователей онлайн
   - Таблицы лидеров в реальном времени
   - Ограничитель потока (для предотвращения злоупотребления API)

3. **Хранилище сеансов**:
   - Статус входа пользователя в систему
   - Содержимое корзины
   - Информация о временной конфигурации

4. **Очереди сообщений**:
   - Простая очередь задач
   - Публикация/подписка на сообщения

```mermaid
graph TD
    subgraph "典型Web应用架构"
        USER["用户请求"] --> APP["应用服务器"]
        APP --> REDIS["Redis缓存"]
        APP --> DB["SQL数据库"]
        
        REDIS -.-> |缓存命中<br/>微秒响应| APP
        DB -.-> |缓存未命中<br/>毫秒响应| APP
        
        APP --> |更新数据| DB
        APP --> |更新缓存| REDIS
    end
```

### 持久性：临时存储还是主存储？

Позиционирование Redis зависит от вашей конфигурации:

**В качестве кэша (режим по умолчанию)**:
- Данные хранятся в памяти
- Данные теряются после перезагрузки сервера
- Основные данные остаются в базе данных SQL
- Redis - это просто слой ускорения

**в качестве основного хранилища (настройте постоянство)**:
- Включите снимки RDB или ведение журнала AOF.
- Данные периодически сохраняются на диск
- Может использоваться как уникальное хранилище для определенных данных

В корпоративных средах, таких как Azure Redis Cache, постоянство часто включается для обеспечения надежности данных.

## 实践建议

### 安全的探索方式

Эти безопасные команды рекомендуется использовать, если вы только начинаете работать с Redis в вашей компании:

```bash
# 查看基本信息
INFO
INFO memory
INFO stats

# 安全地浏览键（避免使用KEYS *）
SCAN 0 MATCH *your-pattern* COUNT 10

# 查看样本数据
RANDOMKEY
TYPE <random-key>
# 然后根据类型使用相应的查看命令
```

### 注意事项

1. **Избегайте блокирующих команд**: в производственных средах команды `KEYS *' и `MONITOR' могут повлиять на производительность.
2. **Используйте SCAN вместо KEYS**: команды SCAN более безопасны для больших наборов данных.
3. **Понимайте концепции баз данных**: помните, что данные в разных базах данных полностью изолированы
4. **Обратите внимание на TTL**: некоторые ключи могут иметь срок действия и будут автоматически удалены после истечения срока действия

Благодаря введению в эту статью, я полагаю, вы получили базовое представление о Redis. Redis - это не просто "быстрое хранилище ключей и значений", это мощный сервер структур данных in-memory для современных приложений, обеспечивающий высокопроизводительную обработку данных.

Далее вы можете попробовать эти команды в безопасной среде, чтобы постепенно познакомиться с операциями Redis. Помните, что ключ к пониманию Redis - это осознание того, что он принципиально отличается от традиционных реляционных баз данных: он плоский, in-memory и ориентирован на структуру данных, и эти характеристики вносят свой вклад в его уникальную ценность.