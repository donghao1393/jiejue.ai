---
title: "Изучение расширенных возможностей регулярных выражений: путешествие от ripgrep к PCRE2"
date: 2025-02-10T13:13:02+04:00
slug: "regexp-advanced-features"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250210131708495.webp"
tags:
  - "регулярное выражение (математика)"
  - "ripgrep"
  - "PCRE2"
  - "обработка текста"
---

Поиск и обработка текста - фундаментальный и важный навык в повседневной работе инженера. Хотя простое сопоставление строк уже может решить многие проблемы, освоение расширенных возможностей регулярных выражений откроет новые двери при столкновении со сложными текстовыми шаблонами. В этой статье мы рассмотрим возможности утилиты ripgrep и регулярного механизма PCRE2.

<! --подробнее-->

## ripgrep и PCRE2: современные мощные средства поиска текста

### ripgrep: почему он так называется?

ripgrep (сокращенно rg) - это современный инструмент поиска, написанный на языке Rust. Слово "rip" в его названии означает "Rest In Peace", что является кивком в сторону традиционного инструмента grep. ripgrep не только унаследовал основную функциональность grep, но и значительно улучшил его производительность и возможности.

### Выбор из двух регулярных движков

По умолчанию ripgrep использует движок регулярных выражений Rust, который реализован в виде конечного автомата для более быстрого выполнения и меньшего объема памяти. Однако, если нам нужны более продвинутые возможности, мы можем включить механизм PCRE2 (Perl Compatible Regular Expressions 2) с помощью параметра `-P`.

```bash
# 使用 PCRE2 引擎
rg -P 'pattern'
```.

## Согласование шаблонов Юникода: обработка многоязычного текста

Обработка многоязычного текста - обычное требование в современном глобализированном мире, и PCRE2 обеспечивает сильную поддержку Unicode:

### Сопоставление шаблонов

```bash
# 匹配汉字
rg -P '\p{Script=Han}'

# 匹配日语平假名
rg -P '\p{Script=Hiragana}'

# 匹配日语片假名
rg -P '\p{Script=Katakana}'

# 匹配西里尔字母
rg -P '\p{Script=Cyrillic}'
```.

### Сопоставление специальных символов

```bash
# 匹配表情符号
rg -P '\p{Extended_Pictographic}'

# 匹配标点符号
rg -P '\p{P}'
``` ## Сопоставление специальных символов

## Условное сопоставление: интеллектуальное распознавание образов

Условное сопоставление позволяет выбирать различные шаблоны сопоставления на основе определенных условий. Это особенно полезно при работе с текстами различных форматов:

```bash
# 格式：(?(?=condition)then|else)
# 示例：如果遇到数字则匹配 foo，否则匹配 bar
rg -P '(?(?=\d)foo|bar)'
```.

Этот шаблон полезен при работе с многоформатным текстом, например с форматами дат, телефонных номеров и т. д:

```bash
# 匹配不同格式的电话号码
rg -P '(?(?=\(\d{3}\))\(\d{3}\)\s?\d{8}|\d{11})'
```

## Атомарные группы: повышение производительности и точности

Атомарные группы - это мощная, но часто упускаемая из виду функция регулярных выражений. Они повышают производительность и обеспечивают точность совпадения, отключая обратный путь.

### Основной синтаксис

```bash
# (?>pattern) 表示一个原子组
rg -P '(?>\w+\s+)+'
```.

### Практическое применение

1. подбор HTML-тегов:
```bash
# 匹配 HTML 标签，但排除 script 和 style 标签
rg -P '(?><(?!script|style)[^<>]+>)'
```

2. Обработка границ слов:
```bash
# 精确匹配单词
rg -P '\b(?>[\w-]+)\b'
```

3. обработка вложенных структур:
```bash
# 匹配不包含嵌套括号的内容
rg -P '\((?>[^()]+)\)'
```

## Отрицательное совпадение: исключение нежелательного содержимого

Отрицательное соответствие - это мощный инструмент, который существует во многих формах, каждая из которых имеет свою специфическую цель:

### Отрицание на основе символов

```bash
# [^...] 匹配任何不在方括号内的单个字符
rg -P '[^0-9]'  # 匹配非数字字符
```.

### Отрицательный обратный поиск

```bash
# (?<!pattern) 确保前面不是特定模式
rg -P '(?<!foo)bar'  # 匹配前面不是 foo 的 bar
```

### Отрицание вперед

```bash
# (?!pattern) 确保后面不是特定模式
rg -P 'foo(?!bar)'  # 匹配后面不是 bar 的 foo
```

## Практический пример: сложная обработка текста

Давайте объединим эти возможности с реальным примером. Предположим, нам нужно извлечь все теги изображений из HTML-файла, но исключить встроенные изображения в формате base64:

```bash
rg -P '(?><img\s+(?!.*src="data:)[^>]+>)'
```.

Состав этого шаблона:
1. `(?>...)` Используйте группы атомов, чтобы обеспечить полное совпадение.
2. `img\s+` Совпадает с началом тега img.
3. `(?!.*src="data:)` Отрицательный поиск, чтобы убедиться, что это не изображение base64.
4. `[^>]+` Соответствует остальной части тега.
5. `>` Сопоставить конец тега

## Соображения по производительности

При использовании этих дополнительных возможностей следует помнить о некоторых моментах:

1. Атомарные группы могут повысить производительность, но их чрезмерное использование может повлиять на читабельность.
2. условное соответствие следует использовать в сценариях, где ветвление действительно необходимо.
3. сопоставление атрибутов Unicode является мощным средством, но может повлиять на производительность.
4. отрицательное соответствие следует использовать с осторожностью, чтобы избежать слишком сложных шаблонов отрицания.

## Заключение

Эти расширенные возможности регулярных выражений значительно расширяют наши возможности по обработке текста. Используя комбинацию этих функций, мы можем создавать эффективные и точные решения для обработки текста. Поскольку спрос на обработку данных растет, овладение этими навыками поможет нам лучше справляться с задачами обработки текста.
