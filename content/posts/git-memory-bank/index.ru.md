---
title: "Git Time Machine: как грациозно удалить чувствительные каталоги из исторических коммитов"
date: 2025-02-23T11:57:36+04:00
slug: "git-remove-sensitive-directory-from-history"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250223115927338.webp"
tags:
  - "Git"
  - "контроль версий"
  - "учебники"
---

При использовании Git для контроля версий мы иногда сталкиваемся с ситуацией, когда каталог или файл случайно фиксируется в репозитории, и этот каталог может содержать содержимое, которое не должно контролироваться. В этот момент нам нужно сохранить файл, удалив его из истории Git'а.

<! -еще-->

## Проблемный сценарий

Предположим, вы создали каталог `memory-bank` для хранения некоторых заметок и контекстной информации во время разработки. Это содержимое, хотя и полезно для разработки, не должно быть включено в систему контроля версий. К сожалению, этот каталог был зафиксирован в репозитории Git.

Теперь перед вами стоят две задачи:
1. удалить каталог из истории Git, чтобы он не появлялся в системе контроля версий
2. сохранить фактическое содержимое каталога, поскольку оно все еще полезно для вас

Это похоже на попытку стереть определенную историю в машине времени, но не затрагивая реальные объекты. Звучит сложновато? Не волнуйтесь, давайте разберемся с этим шаг за шагом.

## Решение

### Шаг 1: Найдите соответствующий коммит

Прежде чем приступить к работе, нам нужно найти момент времени, когда файл был впервые внесён в репозиторий. git предоставляет несколько способов сделать это:

1. используя `git log` с параметрами `--follow` и `--reverse`:
   ```bash
   git log --follow --reverse -- memory-bank/
   ``` Параметры.
   Эта команда отображает полную историю каталога, включая записи о переименовании, в хронологическом порядке, причем самые ранние фиксации отображаются вверху.

2. Используйте `git rev-list`, чтобы найти первую фиксацию напрямую:
   ```bash
   git rev-list --max-parents=0 HEAD -- memory-bank/
   ```.
   Эта команда возвращает хэш, содержащий непосредственно самый ранний коммит для каталога.

3. используйте `git log` с параметром `--diff-filter=A`:
   ```bash
   git log --diff-filter=A -- memory-bank/
   ``` Параметры.
   Эта команда отфильтровывает коммиты из операции Add, которая является первым вхождением в каталог.

Благодаря этому мы можем точно определить точку фиксации, которую необходимо изменить, что очень важно для следующей операции.

### Шаг 2: Резервное копирование важных файлов

Прежде всего, нам нужно сделать резервную копию файлов, которые мы хотим сохранить на случай, если что-то случится во время операции:

```bash
cp -r memory-bank/ /tmp/memory-bank_backup
```

Эта строка копирует каталог `memory-bank` во временную директорию. Почему это необходимо? Потому что следующая операция будет связана с изменением истории Git'а, и нам нужно убедиться, что данные в безопасности.

### Шаг 3: Начало путешествия во времени

Далее мы воспользуемся функцией Git'а по интерактивному rebase:

```bash
git rebase --committer-date-is-author-date -i HEAD~2
```.

Эта команда выглядит немного сложной, поэтому давайте разберём её на части:
- `git rebase -i`: Запускает интерактивный rebase.
- `HEAD~2`: Мы хотим изменить два последних коммита.
- `--committer-date-is-author-date`: этот параметр обеспечивает согласованность временных меток при переписывании истории.

Когда вы выполняете эту команду, Git открывает редактор, показывающий два последних коммита. Каждому коммиту предшествует команда `pick`.

### Шаг 4: Редактирование коммитов

В редакторе найдите коммит, содержащий коммит, связанный с `memory-bank`, и измените `pick` перед ним на `edit`. Это прикажет Git'у приостановиться, когда он достигнет этого фикса, что позволит нам изменить его. Сохраните и закройте редактор.

### Шаг 5: Удалите файл, но сохраните его содержимое

Когда Git приостановится на целевом коммите, выполните следующую команду:

```bash
git rm -r --cached memory-bank/
git commit --amend --no-edit
git rebase --continue
```

Эти команды выполняют следующее:
1. `git rm -r --cached`: удаляет файл из индекса Git, но не удаляет сам файл.
2. `--amend`: изменяет текущий коммит
3. __PROTECTED_INLINE_CODE__25__: оставить информацию о коммите без изменений
4. __PROTECTED_INLINE_CODE__26__: продолжить завершение операции изменения базы

### Шаг 6: Восстановление файла

После завершения операции изменения базы скопируйте резервную копию файла обратно:

```bash
cp -r /tmp/memory-bank_backup/ memory-bank/
```

### Шаг 7: Предотвращение повторных фиксаций

Наконец, не забудьте добавить этот каталог в файл `.gitignore`:

```bash
echo "memory-bank/" >> .gitignore
```

## Принцип объяснен

Весь этот процесс похож на управление машиной времени:
1. сначала мы храним важные объекты (файлы) в безопасном месте
2. мы возвращаемся в прошлое (используя rebase).
3. переписываем историю того момента времени (удаляем файлы).
4. возвращаемся в настоящее и восстанавливаем нужные нам предметы.
5. устанавливаем правила, чтобы предотвратить повторение подобных событий (с помощью .gitignore)

## Примечания

1. **Не выполняйте в общей ветке**: это действие изменяет историю Git и может вызвать конфликты, если другие пользователи также используют эту ветку.

2. **Бэкап перед операцией**: хотя операции с Git'ом обычно безопасны, перед выполнением таких операций, изменяющих историю, нелишним будет сделать резервную копию важных файлов.

3. **Проблемы с правами**: Если каталог содержит некоторые файлы с правами на выполнение, при копировании обратно может потребоваться сбросить права.

4. **Информация о фиксации**: Эта операция сохранит исходную информацию о фиксации без изменений, если вам нужно изменить информацию о фиксации, вы можете удалить параметр `--no-edit`, когда `--amend`.

## Резюме

С помощью этого подхода мы успешно:
1. удалили чувствительные каталоги из истории Git
2. сохранили фактические файлы в каталоге
3. предотвратили повторное коммитирование каталога

Это похоже на идеальное путешествие во времени: изменяем прошлое, но сохраняем настоящее в том виде, в котором оно нам нужно. Эта техника полезна для работы с неправильно зафиксированными конфигурационными файлами, файлами журналов или другим содержимым, которое не должно находиться в системе контроля версий.

Помните: Git - это не просто система контроля версий, это мощная машина времени, которая помогает нам управлять историей каждого фрагмента кода.
