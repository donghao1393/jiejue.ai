---
title: "Как грациозно удалить конфиденциальные файлы из истории Git"
date: 2025-02-18T17:45:37+04:00
slug: "how-to-remove-sensitive-files-from-git-history"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250218174927737.webp"
tags:
  - "Git"
  - "Навыки развития"
  - "практика безопасности"
---

Случайно занесли конфиденциальные файлы (например, конфигурационные файлы, ключи) в Git-репозиторий во время разработки? Не паникуйте, в этой статье мы расскажем вам, как решить эту проблему.

<! ---далее-->

## Сценарий проблемы

Допустим, во время разработки вы случайно зафиксировали в Git-репозитории конфигурационный файл `config.secret.yaml`, содержащий конфиденциальную информацию. Этот файл был добавлен в позавчерашнем коммите, и теперь вам нужно:
1. полностью удалить файл из истории Git.
2. сохранить все остальные изменения кода нетронутыми
3. убедиться, что файл по-прежнему доступен локально, но больше не отслеживается Git'ом

## Шаги по решению проблемы

### 1. Найдите коммит конфиденциального файла.

Сначала нам нужно найти коммит, в котором был добавлен чувствительный файл. Если вы помните, что он был в нескольких последних коммитах, вы можете использовать эту команду, чтобы проверить его:

```bash
git diff HEAD~3 HEAD~2 --name-only
```

Эта команда покажет вам список файлов, которые были добавлены или изменены между третьим и предпоследним коммитами.

### 2. Использование интерактивного rebase

После того как вы нашли нужные коммиты, вы можете использовать интерактивный rebase для изменения истории:

```bash
git rebase -i HEAD~3 --committer-date-is-author-date
```

Эта команда открывает редактор, в котором отображается список трёх последних коммитов, примерно так:

```text
pick abc1234 feat: 添加新功能
pick def5678 feat: 更新配置文件  # 这是包含敏感文件的提交
pick ghi9012 feat: 修复问题
```

### 3. Пометка коммитов для редактирования

В редакторе измените `pick` на `edit` перед коммитом, содержащим чувствительный файл:

```text
pick abc1234 feat: 添加新功能
edit def5678 feat: 更新配置文件  # 改这一行
pick ghi9012 feat: 修复问题
```.

Сохраните и закройте редактор.

### 4. Удаление конфиденциальных файлов

Git приостановится на фиксации, которую вы отметили как `edit`. В этот момент используйте следующую команду, чтобы удалить чувствительный файл:

```bash
git rm --cached config.secret.yaml
```.

Эта команда удаляет файл из системы контроля версий Git'а, но сохраняет его в вашем рабочем каталоге.

### 5. Обновление коммитов

После удаления файла используйте `--amend`, чтобы обновить коммит:

```bash
git commit --amend
```

### 6. Завершите rebase

Наконец, продолжите процесс rebase:

```bash
git rebase --continue
```.

### 7. Предотвращение случайных коммитов в будущем

Чтобы предотвратить случайные коммиты конфиденциальных файлов в будущем, немедленно создайте или обновите файл `.gitignore`:

```bash
echo "config.secret.yaml" >> .gitignore
git add .gitignore
git commit -m "chore: 更新 .gitignore 排除敏感文件"
```

## Принцип объяснения

Давайте воспользуемся простой аналогией, чтобы понять суть процесса:

```mermaid
graph LR
    A[提交 1] --> B[提交 2<br>有敏感文件]
    B --> C[提交 3]
    style B fill:#ffcccc
    
    D[提交 1] --> E[提交 2<br>无敏感文件]
    E --> F[提交 3]
    style E fill:#ccffcc
    
    subgraph 修改前
    A --> C
    end
    
    subgraph 修改后
    D --> F
    end
```.

- Представьте, что вы разбираете фотоальбом (историю Git).
- Представьте, что вы разбираете фотоальбом (историю Git) и понимаете, что в середине (коммит) есть страница, содержащая фотографии, которых там быть не должно (чувствительные файлы).
- Использование `git rebase -i` - это как остановка на этой странице.
- `git rm --cached` - это как вытащить не ту фотографию.
- `git commit --amend` - заново запечатать страницу.
- Последний `git rebase --continue` - закрыть альбом и закончить его.

## Примечания

1. если репозиторий был выгружен на удаленное хранилище, вам нужно использовать `git push --force` для обновления удаленного хранилища.
2. Перед этим стоит создать резервную ветку: `git branch backup-before-remove`.
3. Если вы работаете над командным проектом, убедитесь, что другие участники знают, что вы изменяете историю.
4. Используйте параметр `--committer-date-is-author-date`, чтобы сохранить постоянное время фиксации.

## Резюме

Преимущества этого подхода следующие:
- Точность: удаляются только указанные чувствительные файлы, и никакие другие изменения не затрагиваются.
- Чистота: полностью удаляются из истории Git'а, не оставляя следов.
- Безопасность: локальные файлы остаются неизменными, они просто больше не отслеживаются Git'ом.

Помните, что профилактика лучше лечения. Создание хорошего файла `.gitignore` может помочь вам избежать множества ненужных проблем. Если ваш проект может содержать конфиденциальные файлы, рекомендуется установить соответствующие правила игнорирования в начале проекта.

Наконец, если вам нужно разобраться с более сложными ситуациями (например, очистить определенные типы файлов из всей истории проекта), рассмотрите возможность использования `git-filter-repo`, специализированного инструмента, который является более безопасным и эффективным, чем традиционный `git filter-branch`.
