---
title: "Разрушая границы традиционных краулеров: комплексное решение для подключения браузера пользователя к странице входа в систему с помощью Playwright"
date: 2025-07-05T16:19:16+04:00
slug: "playwright-bypass-login-crawler"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250705162011982.webp"
tags:
  - "Драматург"
  - "веб-гусеница"
  - "Автоматизация браузера"
  - "антикроулер"
  - "MCP"
---

Представьте себе такой сценарий: вы хотите автоматически получить информацию о заказах на Taobao, личные сообщения в Twitter или пакетное управление внутренними системами, но эти сайты либо требуют сложной аутентификации при входе, либо имеют мощный механизм защиты от краулеров. Традиционные краулеры часто оказываются беспомощными перед лицом этих "кирпичных стен", но если я скажу вам, что существует способ напрямую "позаимствовать" ваш браузер, используя ваш статус входа в систему для доступа к этим страницам, вы подумаете, что это удивительно?

<! -еще-->

## Дилемма традиционных краулеров

Как разработчик, вы наверняка сталкивались с этой головной болью:

- **Сложная проверка логина**: CAPTCHA, SMS-проверка, человеко-машинная проверка - бесконечное множество вариантов.
- **Строгое обнаружение антикраулеров**: обнаружение User-Agent, ограничение частоты, блокировка IP-адресов
- **Сложности в управлении сессиями**: истечение срока действия куки, обновление токенов, многоступенчатая аутентификация
- **Приватное содержимое недоступно**: личная домашняя страница, личные сообщения, управление фоном и другие страницы, требующие разрешений.

Проблемы у сотрудника отдела электронной коммерции: ему нужно каждый день проверять данные о магазине на нескольких платформах, вручную входить, проверять, записывать и тратить кучу времени на повторяющийся труд. А при написании краулера приходится заниматься всевозможными проверками, что требует больших затрат.

## Революционное решение Playwright

Playwright предлагает гениальное решение: **подключиться к существующему экземпляру браузера пользователя**. Это как "прикрепление" к вашему браузеру и использование вашего статуса входа, куки и даже расширений браузера.

### Основной принцип: протокол Chrome DevTools Protocol (CDP)

Современные браузеры поддерживают протокол CDP, который изначально был создан для инструментов разработчика, но мы можем "позаимствовать" его для реализации программного управления браузером.

```mermaid
graph LR
    A[用户浏览器] -->|CDP端口9222| B[Playwright脚本]
    B --> C[读取页面内容]
    B --> D[执行用户操作]
    B --> E[获取登录状态]
    
    A --> F[保留所有设置]
    F --> G[Cookie]
    F --> H[登录状态]
    F --> I[浏览器扩展]
```.

## Практическое демо: полная реализация от нуля до одного

### Первый шаг: запуск браузера в режиме отладки

Это критически важный первый шаг во всей программе. Вам нужно разрешить браузеру открыть "черный ход", чтобы позволить внешним приложениям подключаться.

**На macOS: **
```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222
```.

**На Windows:** ```bash
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222
```.
```cmd
chrome.exe --remote-debugging-port=9222
```.

**```cmd
chrome.exe --remote-debugging-port=9222
``` **On Linux.
```bash
google-chrome --remote-debugging-port=9222
```.

Если вы видите вывод, подобный этому, значит, все прошло успешно:
```
DevTools listening on ws://127.0.0.1:9222/devtools/browser/8d2806ff-58c5-43b7-b9f4-eadfdbfe87cf
```

### Шаг 2: Проверьте соединение

Зайдите на страницу `http://localhost:9222/json/version` в браузере, и если вы увидите ответ в формате JSON, значит, порт отладки открыт.

### Шаг 3: Напишите скрипт подключения

Здесь представлены две версии реализации:

#### JavaScript-версия (рекомендуется для начинающих).

```javascript
const { chromium } = require('playwright');

async function connectToUserBrowser() {
    console.log('正在连接到你的浏览器...');
    
    try {
        // 连接到用户的浏览器实例
        const browser = await chromium.connectOverCDP('http://localhost:9222');
        console.log('连接成功！');
        
        // 获取现有的浏览器上下文（包含所有登录状态）
        const context = browser.contexts()[0];
        
        // 获取当前页面或创建新页面
        let page;
        const pages = context.pages();
        if (pages.length > 0) {
            page = pages[0]; // 使用现有页面
            console.log(`当前页面：${await page.title()}`);
        } else {
            page = await context.newPage(); // 创建新页面
        }
        
        // 示例：访问需要登录的淘宝页面
        await page.goto('https://www.taobao.com');
        
        // 检查登录状态
        const isLoggedIn = await page.locator('.site-nav-user').isVisible();
        if (isLoggedIn) {
            console.log('检测到已登录淘宝！');
            
            // 获取用户信息
            const username = await page.locator('.site-nav-user').textContent();
            console.log(`用户名：${username}`);
            
            // 现在可以访问个人中心、订单页面等
            await page.goto('https://trade.taobao.com/trade/itemlist/list_bought_items.htm');
            console.log('成功访问订单页面！');
        }
        
    } catch (error) {
        console.error('连接失败：', error.message);
        console.log('请确保浏览器已开启调试模式');
    }
}

connectToUserBrowser();
```

#### Версия на языке Python (для аналитиков данных)

```python
import asyncio
from playwright.async_api import async_playwright

async def connect_to_user_browser():
    print('正在连接到你的浏览器...')
    
    async with async_playwright() as p:
        try:
            # 连接到用户浏览器
            browser = await p.chromium.connect_over_cdp('http://localhost:9222')
            print('连接成功！')
            
            # 获取现有上下文
            context = browser.contexts[0]
            
            # 创建新页面
            page = await context.new_page()
            
            # 访问微博
            await page.goto('https://weibo.com')
            
            # 检查登录状态
            login_element = await page.query_selector('.login')
            if not login_element:
                print('检测到已登录微博！')
                
                # 获取微博数据
                posts = await page.query_selector_all('.card-wrap')
                print(f'获取到 {len(posts)} 条微博')
                
                # 处理每条微博
                for i, post in enumerate(posts[:5]):  # 只处理前5条
                    text = await post.inner_text()
                    print(f'微博 {i+1}: {text[:50]}...')
            
        except Exception as error:
            print(f'连接失败：{error}')

# 运行
asyncio.run(connect_to_user_browser())
```

## Фактические тестовые данные: проверка реального случая

В реальном тесте я использовал эту схему для успешного подключения к браузеру Vivaldi, содержащему 89 вкладок, и получил следующие результаты:

### Успешный доступ к приватному содержимому:

1. **Личное пространство на сайте B**
   - Поклонники: 265
   - Количество просмотров: 348,000
   - Последние видеоматериалы
   - Персональная статистика

2. **Личная хронология Twitter**
   - Домашняя страница личного аккаунта
   - Приватный рекомендуемый контент
   - Сообщения уведомлений

3. **Администрирование бэкэнда WordPress**
   - Полный интерфейс администратора
   - Доступ к редактированию статей
   - Доступ к конфигурации сайта

4. **Личный чат Клода.ai**
   - Технические обсуждения, содержащие 288 блоков кода
   - Приватный обмен связанным контентом
   - Полная история диалога

### Данные о производительности:

- **Скорость соединения**: < 2 секунд
- **Загрузка страниц**: такая же, как в обычном браузере
- **Стабильность**: сохраняется в течение нескольких часов
- **Совместимость**: поддержка Chrome, Edge, Vivaldi и других браузеров на ядре Chromium.

## Расширение возможностей искусственного интеллекта с помощью MCP

Если вы используете ИИ-помощника, например Claude, вы также можете позволить ему управлять браузером напрямую через MCP (Model Context Protocol). Это революционная функция, которая позволяет ИИ фактически "видеть" и "манипулировать" веб-страницами.

### Настройте MCP одним щелчком мыши

Для клиентов ИИ, поддерживающих MCP, таких как Claude Desktop, Cline и т. д., достаточно добавить следующую конфигурацию JSON в файл конфигурации:

```json
{
  "mcpServers": {
    "Playwright": {
      "command": "npx",
      "args": [
        "-y",
        "@playwright/mcp@latest"
      ]
    }
  }
}
```.

Когда конфигурация будет завершена, ИИ сможет напрямую вызывать функцию Playwright:

```javascript
// AI可以直接执行这些操作
await Playwright.browser_navigate("https://example.com");
await Playwright.browser_type("搜索框选择器", "搜索内容");
await Playwright.browser_click("提交按钮选择器");
await Playwright.browser_take_screenshot();
```

### Уникальные преимущества MCP

ИИ, управляющий браузером с помощью MCP, имеет следующие преимущества перед традиционными методами программирования:

1. **Управление на естественном языке**: Вы можете напрямую сказать ИИ "помогите мне войти на Taobao и проверить последние заказы".
2. **Интеллектуальная адаптация**: ИИ может автоматически корректировать стратегию работы в зависимости от структуры страницы.
3. **Обработка ошибок**: ИИ может автоматически повторять попытки и обрабатывать исключения.
4. **Мгновенная обратная связь**: ИИ может анализировать содержимое страницы и принимать решения в режиме реального времени.

Таким образом, ИИ может управлять веб-страницами как человек и выполнять сложные автоматизированные задачи.

## Сценарии применения: решение реальных проблем

### 1. Автоматизация работы электронной коммерции

**Сценарий**: Сяо Ван управляет магазинами на 10 различных платформах и должен ежедневно проверять заказы, отвечать на запросы клиентов и обновлять товары.

**Решение**:
```javascript
// 自动检查各平台订单
const platforms = ['taobao', 'jd', 'pinduoduo'];
for (const platform of platforms) {
    await checkOrders(platform);
    await replyMessages(platform);
    await updateInventory(platform);
}
```.

### 2. Управление социальными сетями

**Сценарий**: Создателям контента необходимо синхронно публиковать материалы на Weibo, Xiaohongshu, Jieyin и других платформах.

**Решение**:
```javascript
// 批量发布内容
const content = {
    text: "今天分享一个实用技巧...",
    images: ["image1.jpg", "image2.jpg"]
};

await publishToWeibo(content);
await publishToXiaohongshu(content);
await publishToDouyin(content);
```.

### 3. Автоматизация внутренних систем предприятия

**Сценарий**: отделу кадров необходимо еженедельно обновлять информацию о сотрудниках и формировать отчеты в нескольких системах.

**Решение**:
```javascript
// 自动化HR流程
await updateEmployeeInfo();
await generateWeeklyReport();
await submitToApprovalSystem();
```.

## Безопасность и соответствие нормативным требованиям

### Меры безопасности

1. **Локальная работа**: все операции выполняются локально, и утечка данных исключена
2. **Авторизация пользователя**: требуется, чтобы пользователи активно открывали порт отладки
3. **Прозрачность и контролируемость**: пользователи могут просматривать и останавливать работу скрипта в любое время.
4. **Наследование привилегий**: использование существующих прав пользователя, не превышающих права доступа

### Рекомендации по соответствию

1. **Соблюдение условий сайта**: убедитесь, что автоматическое поведение соответствует условиям использования сайта.
2. **Контроль частоты**: избегайте слишком частых запросов.
3. **Защита данных**: обращайтесь с полученными данными надлежащим образом, чтобы защитить конфиденциальность.
4. **Коммерческое использование**: перед коммерческим использованием ознакомьтесь с соответствующими юридическими условиями.

## Часто задаваемые вопросы

### Вопрос: В чем преимущества этого метода перед традиционными краулерами?

О: К основным преимуществам относятся:
- **Нет входа**: напрямую используйте существующий статус входа.
- **Антиобнаружение**: используется реальная среда браузера, нелегко быть распознанным
- **Полная функциональность**: поддержка JavaScript, Cookie, Session и т.д.
- **Поддержка плагинов**: можно использовать преимущества расширений браузера, таких как блокировщики рекламы

### Q: Повлияет ли это на нормальное использование браузера?

О: Нет. Скрипт просто "прикрепляется" к браузеру, и вы можете просматривать веб-страницы в обычном режиме. Новые вкладки, созданные скриптом, будут четко обозначены.

### Q: Какие браузеры поддерживаются?

О: Поддерживаются все браузеры на базе Chromium:
- Google Chrome
- Microsoft Edge
- Vivaldi
- Вивальди
- Opera
и т.д.

### Q: Как работать с динамическим содержимым на странице?

О: В Playwright есть мощный встроенный механизм ожидания:
```javascript
// 等待元素出现
await page.waitForSelector('.dynamic-content');

// 等待网络请求完成
await page.waitForLoadState('networkidle');

// 等待特定条件
await page.waitForFunction(() => window.dataLoaded === true);
```

### Q: Где находится файл конфигурации MCP?

О: Расположение файла конфигурации для разных клиентов:

**Claude Desktop:**.
- macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Windows: `%APPDATA%\Claude\claude_desktop_config.json`

**Клин (плагин для VS Code):**.
- Откройте Settings в VS Code и найдите "Cline: MCP".
- или просто отредактируйте рабочее пространство `.vscode/settings.json`.

Просто добавьте конфигурацию JSON в соответствующий файл.

## Дополнительные советы

### 1. Пакетная обработка нескольких учетных записей

```javascript
// 使用不同的用户数据目录
const contexts = [
    { port: 9222, name: '账号1' },
    { port: 9223, name: '账号2' },
    { port: 9224, name: '账号3' }
];

for (const ctx of contexts) {
    const browser = await chromium.connectOverCDP(`http://localhost:${ctx.port}`);
    await processAccount(browser, ctx.name);
}
```

### 2. Обработка ошибок и механизм повторных попыток

```javascript
async function robustOperation(page, operation, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await operation(page);
        } catch (error) {
            console.log(`尝试 ${i + 1} 失败：${error.message}`);
            if (i === maxRetries - 1) throw error;
            await page.waitForTimeout(1000 * (i + 1)); // 递增延迟
        }
    }
}
```

### 3. Сохранение данных

```javascript
// 保存浏览器状态供下次使用
await context.storageState({ path: 'user-session.json' });

// 下次直接加载状态
const context = await browser.newContext({ 
    storageState: 'user-session.json' 
});
```

## Резюме

С помощью схемы подключения Playwright к браузеру пользователя мы успешно преодолели ограничения традиционных краулеров и реализовали их:

1. **Непороговый вход**: нет необходимости в сложном процессе аутентификации.
2. **Имитация реальной среды**: использование отпечатков пальцев и настроек реального браузера.
3. **Доступ к приватному контенту**: получение данных со страниц, требующих разрешений.
4. **Высокая степень автоматизации**: в сочетании с искусственным интеллектом достигается интеллектуальная работа

Это решение особенно подходит для индивидуальных разработчиков и небольших команд, помогая им быстро реализовать свои потребности в веб-автоматизации. Независимо от того, занимаетесь ли вы электронной коммерцией, создаете контент или являетесь ИТ-администратором предприятия, вы сможете найти подходящие сценарии его применения.

Помните, что технология нейтральна; все дело в том, как ответственно ее использовать. Наслаждаясь удобством автоматизации, важно также соблюдать условия использования сайта и конфиденциальность пользователей.

## Список быстрого запуска

Для читателей, которым не терпится опробовать эту технологию, мы предлагаем список для быстрого старта:

### Базовая версия (управление программированием)
1. ☑️ Запустите браузер в режиме отладки
2. ☑️ Установите Playwright: __PROTECTED_INLINE_CODE__20__.
3. ☑️ Скопируйте пример кода из статьи.
4. ☑️ Запустите первый тестовый скрипт

### Версия MCP (управление искусственным интеллектом)
1. ☑️ Добавьте конфигурацию MCP в файл конфигурации клиента AI.
2. ☑️ Перезапустите клиент AI.
3. ☑️ Скажите AI напрямую: "Пожалуйста, посетите Taobao и сделайте скриншот".

Начните свой путь автоматизации прямо сейчас! Начните с простого посещения страницы и шаг за шагом создавайте своего специального веб-помощника.
