---
title: "Руководство по исправлению ошибок в Git: как отменить ошибочные коммиты"
date: Fri Mar 07 2025 20:23:27 GMT+0000 (Coordinated Universal Time)
slug: "git-undo-commands-guide"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250308002608381.webp"
tags:
  - "Git"
  - "инструмент разработки"
  - "контроль версий"
  - "технический навык"
---

## 前言：人非圣贤，孰能无错？

Коммиты с ошибками практически неизбежны в повседневной работе по разработке кода - будь то случайная фиксация куска отладочного кода, фиксация изменений в неправильной ветке или опечатка в сообщении коммита. Все это нормальные "казусы" в процессе разработки.

<!--more-->

Git, как самая популярная система контроля версий, не только предоставляет мощные возможности версионирования, но и имеет множество встроенных команд "исправления", помогающих разработчикам изящно справляться с этими ошибками. В этой статье мы систематически познакомим вас с этими часто используемыми командами "отмены", чтобы помочь начинающим разработчикам быстро овладеть этими навыками.

## Git中的"后悔药"种类

Git предлагает несколько различных методов "отмены", каждый из которых подходит для разных сценариев. Важно понимать разницу между ними, чтобы сделать правильный выбор:

- **Отменить локальные изменения**: для изменений, которые еще не были зафиксированы
- **Модифицировать последний коммит**: для изменений, которые только что были зафиксированы, но ещё не выложены
- **Undo pushed commits**: для неверных коммитов, которые были размещены в удаленном репозитории
- **Выборочное восстановление**: восстановление только определенных файлов или определенных фиксаций

Ниже мы подробно расскажем, как именно работают эти сценарии.

## 一、撤销工作区和暂存区的修改

### 场景1：丢弃工作区的修改

Предположим, вы редактируете файл, и выясняется, что изменения совершенно неправильные, и вы хотите их отменить.

```bash
git checkout -- <file>
```

Или используйте обновленный синтаксис:

```bash
git restore <file>
```

Эта команда восстановит файл до состояния последней фиксации, **но учтите**: при этом будут потеряны все несохранённые изменения!

### 场景2：撤销已暂存但未提交的修改

Если вы уже добавили изменения в область хранения с помощью `git add`, но еще не зафиксировали их:

```bash
git reset HEAD <file>
```

Или используйте новый синтаксис:

```bash
git restore --staged <file>
```

Эта команда удаляет файл из области постановки, но сохраняет изменения в рабочей области.

## 二、修改或撤销最近的提交

### 场景3：修改最近的提交信息

Если вы только что отправили заявку, но поняли, что сообщение об отправке написано неправильно:

```bash
git commit --amend -m "新的提交信息"
```

Эта команда заменяет последнюю фиксацию на новую.

### 场景4：向最近的提交添加遗漏的文件

Забыли добавить несколько файлов в последний коммит? Не нужно создавать новый коммит:

```bash
git add <遗漏的文件>
git commit --amend --no-edit
```

Параметр `--no-edit` указывает, что сообщение о фиксации не будет изменено.

### 场景5：完全撤销最近的几次本地提交

Если вы хотите полностью отказаться от нескольких последних коммитов, можно воспользоваться командой `reset`:

```bash
# 软重置 - 保留工作区和暂存区的修改
git reset --soft HEAD~n

# 混合重置 - 保留工作区修改，但清除暂存区（默认模式）
git reset HEAD~n

# 硬重置 - 完全丢弃更改
git reset --hard HEAD~n
```

где `n` указывает количество коммитов для отката.

**ПРЕДУПРЕЖДЕНИЕ**: Опция `--hard` безвозвратно теряет все незафиксированные изменения и откатывает фиксации! Пожалуйста, используйте ее с осторожностью.

## 三、撤销已推送的提交

### 场景6：通过新提交撤销已推送的提交

Если ваш ошибочный коммит уже был отправлен в удалённый репозиторий, вам следует создать новый коммит "undo", чтобы не нарушить историю:

```bash
git revert <commit-hash>
```

Эта команда создаёт новый коммит с изменениями, противоположными указанному коммиту, фактически "отменяя" этот коммит.

### 场景7：撤销多个连续的已推送提交

Если необходимо отменить ряд последовательных фиксаций:

```bash
git revert --no-commit <older-commit-hash>^..<newer-commit-hash>
git commit -m "撤销从A到B的多个提交"
```

Параметр `--no-commit` помещает все операции отмены в область хранения вместо того, чтобы создавать новую фиксацию для каждой отмененной фиксации.

## 四、高级修复技巧

### 场景8：交互式变基修改历史

Для более сложных исторических ревизий мощным инструментом является интерактивная база переменных:

```bash
git rebase -i HEAD~n
```

Откроется редактор, в котором вы сможете:
- Изменить сообщение фиксации, изменив `pick` на `reword`.
- Изменить коммит, изменив `pick` на `edit`.
- Объединить коммиты, изменив `pick` на `squash` или `fixup`.
- Удалить коммиты, изменив `pick` на `drop`.

**Примечание**: Используйте это только для коммитов или приватных веток, которые не были вытеснены, так как это изменит историю.

### 场景9：使用cherry-pick选择性应用提交

Если вы хотите применить определенный коммит к текущей ветке:

```bash
git cherry-pick <commit-hash>
```

Эта команда отлично подходит для выборочного применения изменений из других веток.

### 场景10：恢复意外删除的分支或提交

Если вы случайно удалили ветку или использовали опцию `--hard`:

```bash
# 查看引用日志
git reflog

# 恢复到指定的状态
git checkout -b <new-branch-name> <commit-hash>
```

`reflog` записывает все операции, которые вы выполняете в локальном хранилище, и действует как "страховочная сетка" на случай случай случайной операции.

## 最佳实践：减少撤销操作的需求

Хотя Git предоставляет множество способов исправить ошибки, лучшей стратегией является снижение вероятности их совершения:

1. **фиксируйте небольшими шагами**: часто фиксируйте небольшие, значимые изменения, а не накапливайте большое количество изменений
2. **Проверка перед фиксацией**: используйте `git diff ---staged` для проверки изменений, подлежащих фиксации
3. **Чёткая политика ветвления**: следуйте процессу ветвления, принятому в вашей команде.
4. **Используйте псевдонимы**: создайте псевдонимы Git для общих команд, чтобы уменьшить количество ошибок при вводе.
5. **Используйте инструменты с графическим интерфейсом**: для визуалов использование графического интерфейса может быть более интуитивным.

## 总结：安全地使用"后悔药"

Команда "Отменить" в Git'е очень мощная, но использовать ее нужно с осторожностью. Новичкам я рекомендую придерживаться следующих правил:

1. для неотправленных изменений вы можете использовать команды `reset`, `commit --amend` и другие команды для изменения истории
2. для изменений, которые уже были выложены, используйте `revert` для создания отменяющего коммита, чтобы избежать изменения общей истории.
3. Перед выполнением разрушительных действий создайте резервную ветку с помощью `git branch backup`.
4. Если вы не уверены в эффекте команды, сначала попробуйте ее в тестовом репозитории.

Наконец, помните основную концепцию дизайна Git: почти все операции можно восстановить, поэтому смело экспериментируйте, но при этом не забывайте о благоговении.

Освоив эти команды "отмены", вы сможете более уверенно использовать Git, не беспокоясь о необратимых последствиях одной ошибки. В конце концов, в разработке программного обеспечения умение изящно справляться с ошибками - важная составляющая профессионального разработчика.

## 常见问题解答

**Вопрос 1: Могу ли я отменить слияние, которое было оттеснено? **
- Да, используйте `git revert -m 1 <merge-commit-hash>`. Параметр `-m 1` означает сохранение изменений в мастер-ветке.

**Вопрос 2: Как восстановить потерянные данные после сброса настроек? **
- Используйте `git reflog` для просмотра истории операций, затем используйте `git checkout` или `git reset` для восстановления нужного состояния.

**Вопрос 3: Я совершил фиксацию в неправильной ветке, как это исправить? **
- Сначала убедитесь, что текущее изменение зафиксировано. Затем переключитесь на правильную ветку, примените фиксацию с помощью `git cherry-pick`, и, наконец, вернитесь на неправильную ветку и удалите фиксацию.

**Вопрос 4: В чем разница между интерактивным изменением базы и вишневым сбором? **
- Интерактивное изменение varbase позволяет вам изменять серию последовательных коммитов, в то время как cherry-pick фокусируется на применении одного коммита из одной ветки в другую.

**Вопрос 5: В чем основная разница между git revert и git reset? **
- `git revert` создает новый коммит, чтобы отменить изменения и сохранить историю; `git reset` изменяет историю и перемещает указатель ветки в предыдущее состояние. После переноса в общий репозиторий следует использовать `revert` вместо `reset`.