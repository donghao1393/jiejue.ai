---
title: "Секреты временных каталогов: логика безопасности, скрывающаяся за /tmp и /private/tmp"
date: 2025-04-15T23:14:00+04:00
slug: "tmp-private-tmp-security"
draft: false
cover: "https://jiejue.obs.ap-southeast-1.myhuaweicloud.com/20250415231607011.webp"
tags:
  - "файловая система"
  - "поручительство"
  - "macOS"
  - "Linux"
---

Почему `/tmp` и `/private/tmp` кажутся одним и тем же каталогом в macOS, но могут по-разному обрабатываться с точки зрения контроля безопасности? Каких лучших практик следует придерживаться, когда нам нужны временные каталоги для экспериментов? В этой статье мы раскроем технические тайны и соображения безопасности, лежащие в основе временных каталогов.

<! -еще-->

Когда мы используем компьютер, нам часто требуется некое "временное" рабочее пространство, где мы можем безопасно проводить эксперименты и тесты, не беспокоясь о том, что испортим остальную часть системы. В процессе работы мы можем столкнуться с двумя каталогами, которые выглядят одинаково, но не совсем одинаковы: `/tmp` и `/private/tmp`. Какая между ними связь? Почему они разработаны именно таким образом? Какая логика безопасности скрывается за этим?

## Знакомство с командой mktemp: отличный помощник для временной работы

Прежде чем исследовать тайны временных каталогов, давайте познакомимся с очень полезной командой: `mktemp`. Эта команда специально предназначена для создания временных файлов или каталогов и особенно полезна при программировании сценариев и в экспериментальных средах.

Представьте, что Минг - системный администратор, которому необходимо часто тестировать новые скрипты. Он не хочет засорять свою рабочую среду тестами, но ему нужно надежное место для их запуска. Вот тут-то и пригодится `mktemp`.

```bash
# 创建临时文件
TEMP_FILE=$(mktemp)
echo "临时文件位置: $TEMP_FILE"

# 创建临时目录
TEMP_DIR=$(mktemp -d)
echo "临时目录位置: $TEMP_DIR"
```

Самое большое преимущество использования `mktemp` заключается в том, что он генерирует уникальные имена файлов и позволяет избежать конфликтов имен, что делает его идеальным для использования в скриптах. Однако важно отметить, что `mktemp` создает только временные файлы или каталоги и не очищает их автоматически. После завершения работы нам нужно вручную удалить эти временные файлы.

## Полный временный рабочий процесс

Хороший временный рабочий процесс должен включать три этапа: создание, использование и очистку. Ниже приведен полный пример из оболочки рыбы:

```fish
function do_experiment
    # 1. 创建临时工作空间
    set -l temp_dir (mktemp -d)
    echo "在 $temp_dir 中进行实验"
    
    # 2. 进入临时目录并工作
    pushd $temp_dir
    
    # 你的实验代码
    # ...
    
    # 3. 完成后返回原目录
    popd
    
    # 4. 清理临时环境
    rm -rf $temp_dir
end
```.

Таким образом, весь эксперимент заключен в одной функции, а временная среда автоматически создается и очищается, чтобы временные файлы не накапливались и не занимали место на диске.

## Загадочные отношения между /tmp и /private/tmp

Когда мы используем `mktemp`, он обычно создает файлы во временном каталоге системы, который в Unix-подобных системах обычно находится в `/tmp`. В macOS, однако, интересно отметить, что `/tmp` на самом деле является символической ссылкой на `/private/tmp`.

```bash
$ realpath /tmp
/private/tmp
```.

Что здесь происходит?

### Символьные ссылки: баланс между удобством и безопасностью

При разработке macOS (ранее Mac OS X) некоторые стандартные каталоги Unix (такие как `/tmp`, `/var` и `/etc`) реализованы как символические ссылки на соответствующие подкаталоги под `/private`. PROTECTED_INLINE_CODE_19__) реализованы как символические ссылки на соответствующие подкаталоги в `/private`. Для такой конструкции есть несколько важных причин:

1. **ИСТОРИЧЕСКАЯ СОВМЕСТИМОСТЬ**: macOS основана на NeXTSTEP и BSD Unix, и такой дизайн позволяет системе поддерживать совместимость с унаследованными Unix-приложениями, организуя при этом файловую систему по-своему.

2. **Ясность архитектуры системы**: централизация специфических для системы каталогов в `/private` делает структуру файловой системы более понятной, а также облегчает обновление и поддержку системы.

3. **Изоляция безопасности**: этот дизайн обеспечивает уровень абстракции, который позволяет системе адаптировать внутреннюю реализацию без изменения внешнего интерфейса.

### Тонкие различия в моделях безопасности

В то время как в повседневной жизни большинство пользователей и приложений могут без проблем получать доступ к одним и тем же файлам через `/tmp` или `/private/tmp`, в жестко контролируемой среде безопасности эти два пути могут восприниматься по-разному.

Например, в некоторых инструментах безопасности или средах "песочницы" символические ссылки могут обрабатываться особым образом, проверяя не только то, что сама символическая ссылка находится в пределах разрешенного доступа, но и то, что фактическая цель, на которую она указывает, также имеет разрешенный доступ.

Этот механизм двойной проверки предотвращает потенциальные атаки обхода привилегий. Если представить себе программу, которой разрешен доступ только к `/tmp`, но при этом не проверяется цель символической ссылки, злоумышленник сможет создать вредоносные символические ссылки, указывающие на важные области системы, и таким образом обойти ограничения безопасности.

## Внутренняя логика реализации средств безопасности

Давайте посмотрим, как типичный инструмент контроля доступа к файловой системе реализует эту защиту. Вот упрощенный псевдокод:

```typescript
async function validatePath(requestedPath) {
  // 1. 检查请求的路径是否在允许列表中
  if (!isPathInAllowedList(requestedPath)) {
    throw new Error("访问被拒绝：路径不在允许的目录中");
  }

  // 2. 如果是符号链接，还要检查它指向的真实路径
  const realPath = getRealpathOfSymlink(requestedPath);
  if (!isPathInAllowedList(realPath)) {
    throw new Error("访问被拒绝：符号链接目标不在允许的目录中");
  }

  return realPath;
}
```.

Этот механизм двойной аутентификации гарантирует, что к каталогам, доступ к которым явно не разрешен, нельзя получить даже через символические ссылки, обеспечивая тем самым более надежную защиту.

## Рекомендации по лучшей практике

Исходя из вышеизложенного, мы приводим несколько рекомендаций по работе с временными файлами и каталогами:

1. **Используйте `mktemp` для создания временных файлов/каталогов**: это безопаснее, чем задавать имена временных файлов вручную, и позволяет избежать конфликтов имен.

2. **Всегда очищайте временные файлы**: явно удаляя временные файлы в конце сценария или программы, рассмотрите возможность использования команды `trap`, чтобы обеспечить очистку даже в случае ошибки.

3. **Учитывайте последствия символических ссылок для безопасности**: При работе с путями, содержащими символические ссылки, имейте в виду, что в некоторых контекстах безопасности к ним может быть особое отношение.

4. **В средах, чувствительных к безопасности**: Если вы пишете инструменты, требующие строгого контроля безопасности, подумайте о проверке как символических ссылок, так и реальных путей, на которые они указывают.

## Заключение

Временные каталоги могут показаться простыми, но в них есть скрытый секрет. От использования команды `mktemp`, взаимосвязи между `/tmp` и `/private/tmp` до более глубоких соображений о безопасности файловой системы - мы видим, как разработчики операционных систем находят баланс между удобством и безопасностью.

Понимание этих, казалось бы, незначительных деталей не только поможет нам лучше использовать системные инструменты, но и углубит наше понимание проектного мышления в области компьютерной безопасности. Такое глубокое понимание особенно ценно сегодня, когда цифровая безопасность приобретает все большее значение.

Как вы обычно обращаетесь с временными файлами? Замечали ли вы особое отношение к символическим ссылкам в средствах контроля безопасности? Не стесняйтесь делиться своим опытом и соображениями в разделе комментариев.
